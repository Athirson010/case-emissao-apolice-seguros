{
  "metadata": {
    "document_type": "Documentação Consolidada do Desafio Técnico",
    "source_files": [
      "README.md",
      "validation-rules.json",
      "order-component-test",
      "consumers de pagamentos e seguros",
      "docker-compose.yml (planejado)"
    ],
    "notes": "Arquivo único consolidando regras de negócio, arquitetura, testes, mensageria, premissas e pendências conforme solicitado."
  },
  "context": {
    "summary": "Esta documentação consolida todas as decisões técnicas, regras de negócio, arquitetura, testes e premissas do desafio de emissão de apólices. O objetivo é explicitar o racional por trás do código, garantir rastreabilidade das regras do validation-rules.json, justificar escolhas técnicas e indicar claramente o que foi ou não desenvolvido por restrição de tempo.",
    "business_rules": {
      "state_machine": "A aplicação implementa uma máquina de estados estrita para a solicitação de apólice: RECEIVED → VALIDATED → PENDING → (APPROVED | REJECTED | CANCELLED). Estados finais são imutáveis.",
      "final_state_conditions": {
        "APPROVED": "AMBAS respostas (pagamento E subscrição) APPROVED",
        "REJECTED": "QUALQUER resposta (pagamento OU subscrição) REJECTED - rejeição imediata",
        "CANCELLED": "Solicitação explícita do cliente antes de estados finais"
      },
      "rejection_logic": {
        "rule": "REJEIÇÃO IMEDIATA COM HISTÓRICO COMPLETO",
        "description": "Se qualquer resposta (pagamento OU subscrição) vier como REJECTED, o status muda para REJECTED imediatamente. Mesmo após rejeitado, quando a segunda resposta chegar, ela deve ser registrada no histórico.",
        "scenarios": [
          {
            "scenario": "Pagamento rejeitado primeiro",
            "behavior": "Status muda para REJECTED imediatamente. Quando subscrição chegar (aprovada ou rejeitada), adiciona entrada no histórico mantendo status REJECTED."
          },
          {
            "scenario": "Subscrição rejeitada primeiro",
            "behavior": "Status muda para REJECTED imediatamente. Quando pagamento chegar (aprovado ou rejeitado), adiciona entrada no histórico mantendo status REJECTED."
          },
          {
            "scenario": "Ambas rejeitadas",
            "behavior": "Primeira rejeição muda status para REJECTED. Segunda rejeição adiciona nova entrada no histórico. Histórico contém ambos os motivos de rejeição."
          },
          {
            "scenario": "Uma aprovada, outra rejeitada",
            "behavior": "Rejeitada muda status para REJECTED. Aprovada adiciona entrada no histórico indicando que foi aprovada após rejeição da outra."
          }
        ],
        "history_guarantee": "O histórico SEMPRE contém o resultado de AMBAS as respostas (pagamento E subscrição), independente da ordem de chegada ou dos resultados individuais."
      }
    },
    "mensageria": {
      "broker_choice": {
        "selected": "RabbitMQ (recomendado)",
        "alternatives": [
          "Apache Kafka",
          "ActiveMQ",
          "IBMMQ",
          "AWS SQS"
        ],
        "justification": "RabbitMQ oferece interface gráfica e CLI simples, facilitando reprodução de testes e inspeção de mensagens."
      },
      "message_format": {
        "format": "JSON",
        "avro_decision": "Avro não foi utilizado por restrição de tempo do desafio, priorizando entrega funcional, clareza e cobertura de testes."
      },
      "interaction_examples": {
        "payment_events": [
          "PAYMENT_CONFIRMED",
          "PAYMENT_REFUSED"
        ],
        "insurance_events": [
          "INSURANCE_AUTHORIZED",
          "INSURANCE_DENIED"
        ],
        "correlation": "Todos os eventos são correlacionados pelo ID da solicitação de apólice."
      },
      "status": "PARCIALMENTE IMPLEMENTADO",
      "notes": "Consumers existem, porém exemplos de uso via CLI/UI e configuração completa do broker ainda precisam ser documentados."
    },
    "infrastructure": {
      "docker_compose": {
        "should_contain": [
          "Banco de dados",
          "Broker de mensageria",
          "Mock Server (API de Fraudes)",
          "Aplicação principal"
        ],
        "status": "NÃO IMPLEMENTADO",
        "notes": "A criação do docker-compose.yml completo ficou fora do escopo por limitação de tempo."
      }
    },
    "testing_strategy": {
      "approach": [
        "Testes unitários",
        "Testes de componentes",
        "Cobertura das regras do validation-rules.json"
      ],
      "component_tests": "Cenários cobrem todas as transições válidas, inválidas, estados finais e eventos fora de ordem.",
      "test_data_strategy": {
        "change": "Substituição de TestDataFixtures por templates",
        "details": "Diretório templates utiliza builders semânticos para compor fluxos completos (policy, pagamento, seguro)."
      },
      "status": "IMPLEMENTADO (CÓDIGO) / PARCIALMENTE DOCUMENTADO"
    },
    "architecture_and_design": {
      "clean_architecture": "Separação clara entre domínio, aplicação e infraestrutura. Consumers, persistência e mensageria são detalhes externos.",
      "abstraction_and_coupling": "Integrações externas são acessadas via interfaces (ports), reduzindo acoplamento e facilitando substituições.",
      "extensibility_and_cohesion": "Regras de negócio e máquina de estados estão centralizadas no domínio, garantindo alta coesão e fácil evolução.",
      "design_patterns": [
        {
          "pattern": "State",
          "usage": "Controle das transições válidas da policy"
        },
        {
          "pattern": "Strategy",
          "usage": "Validações por perfil de risco e capital segurado"
        },
        {
          "pattern": "Builder / Template",
          "usage": "Criação de cenários complexos nos testes de componentes"
        },
        {
          "pattern": "Factory (conceitual)",
          "usage": "Criação de eventos de domínio e mensagens de integração"
        }
      ],
      "solid_principles": {
        "SRP": "Cada classe possui uma única responsabilidade",
        "OCP": "Novos estados e regras podem ser adicionados sem alterar código existente",
        "DIP": "Dependência de abstrações e não de implementações concretas"
      },
      "clean_code": "Código com nomes explícitos, métodos pequenos e testes que documentam o comportamento esperado."
    },
    "observability": {
      "logging": "Logs registram transições de estado e consumo de eventos",
      "metrics_and_traces": "Não implementados",
      "status": "PARCIALMENTE IMPLEMENTADO"
    },
    "premises_and_assumptions": [
      "Eventos fora de ordem são rejeitados ou ignorados conforme o estado atual",
      "Estados finais são imutáveis",
      "Pagamento e seguro são obrigatórios para aprovação",
      "Design Patterns são aplicados de forma pragmática, evitando superengenharia"
    ]
  },
  "contradictions_or_conflicts": [],
  "errors_or_warnings": [
    {
      "issue_type": "documentation_gap",
      "description": "README.md ainda não consolida todos os pontos exigidos pelo desafio.",
      "proposed_solution": "Utilizar este arquivo como base para atualizar o README.md."
    },
    {
      "issue_type": "infrastructure_gap",
      "description": "Infraestrutura completa via docker-compose não foi desenvolvida.",
      "proposed_solution": "Documentar explicitamente a limitação de tempo e a abordagem planejada."
    },
    {
      "issue_type": "mensageria_examples_missing",
      "description": "Faltam exemplos reproduzíveis de publicação/consumo de mensagens.",
      "proposed_solution": "Adicionar exemplos via CLI/UI do broker escolhido no README."
    }
  ]
}
